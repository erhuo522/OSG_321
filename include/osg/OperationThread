/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSG_OPERATIONTHREAD
#define OSG_OPERATIONTHREAD 1

#include <osg/observer_ptr>
#include <osg/Object>

#include <OpenThreads/Thread>
#include <OpenThreads/Barrier>
#include <OpenThreads/Condition>
#include <OpenThreads/Block>

#include <list>
#include <set>

namespace osg {

//线程安全，带引用计数器的Block
class RefBlock : virtual public osg::Referenced, public OpenThreads::Block
{
    public:

        RefBlock():
            osg::Referenced(true) {}

};
//线程安全，带引用计数器的BlockCount
class RefBlockCount : virtual public osg::Referenced, public OpenThreads::BlockCount
{
    public:

        RefBlockCount(unsigned blockCount):
            osg::Referenced(true),
            OpenThreads::BlockCount(blockCount) {}

};

/** Base class for implementing graphics operations.*/
//操作的基类
class Operation : virtual public Referenced
{
    public:

        Operation(const std::string& name, bool keep):
            osg::Referenced(true),
            _name(name),
            _keep(keep) {}


        /** Set the human readable name of the operation.*/
        void setName(const std::string& name) { _name = name; }

        /** Get the human readable name of the operation.*/
        const std::string& getName() const { return _name; }

        /** Set whether the operation should be kept once its been applied.*/
        void setKeep(bool keep) { _keep = keep; }

        /** Get whether the operation should be kept once its been applied.*/
        bool getKeep() const { return _keep; }

        /** if this operation is a barrier then release it.*/
        virtual void release() {}

        /** Do the actual task of this operation.*/
        virtual void operator () (Object*) = 0;

    protected:

        Operation():
            Referenced(true),
            _keep(false) {}

        Operation(const Operation& op):
            Referenced(true),
            _name(op._name),
            _keep(op._keep) {}

        virtual ~Operation() {}

        std::string _name; //名字
        bool        _keep; //是否保持到apply才释放
};

class OperationThread;

class OSG_EXPORT OperationQueue : public Referenced
{
    public:

        OperationQueue();

        /** Get the next operation from the operation queue.
          * Return null ref_ptr<> if no operations are left in queue. */
        osg::ref_ptr<Operation> getNextOperation(bool blockIfEmpty = false);

        /** Return true if the operation queue is empty. */
		//判断队列中的操作是否为空
        bool empty();

        /** Return the num of pending operations that are sitting in the OperationQueue.*/
		//获得队列中的操作数量
        unsigned int getNumOperationsInQueue();

        /** Add operation to end of OperationQueue, this will be
          * executed by the operation thread once this operation gets to the head of the queue.*/
		//添加操作
        void add(Operation* operation);

        /** Remove operation from OperationQueue.*/
		//移除操作
        void remove(Operation* operation);

        /** Remove named operation from OperationQueue.*/
		//移除名字为name的操作
        void remove(const std::string& name);

        /** Remove all operations from OperationQueue.*/
		//清空所有操作
        void removeAllOperations();

        /** Run the operations. */
        void runOperations(Object* callingObject=0);

        /** Call release on all operations. */
		//释放所有操作
        void releaseAllOperations();

        /** Release operations block that is used to block threads that are waiting on an empty operations queue.*/
        void releaseOperationsBlock();

        typedef std::set<OperationThread*> OperationThreads;

        /** Get the set of OperationThreads that are sharing this OperationQueue. */
        const OperationThreads& getOperationThreads() const { return _operationThreads; }

    protected:

        virtual ~OperationQueue();

        friend class OperationThread;

		//添加操作线程
        void addOperationThread(OperationThread* thread);
		//移除操作线程
        void removeOperationThread(OperationThread* thread);

        typedef std::list< osg::ref_ptr<Operation> > Operations;
		
		//互斥对象
        OpenThreads::Mutex          _operationsMutex;
		//Block对象
        osg::ref_ptr<osg::RefBlock> _operationsBlock;
		//操作的list链表
        Operations                  _operations;
		//当前操作的迭代器
        Operations::iterator        _currentOperationIterator;

		//线程set集合
        OperationThreads            _operationThreads;
};

/** OperationThread is a helper class for running Operation within a single thread.*/
class OSG_EXPORT OperationThread : public Referenced, public OpenThreads::Thread
{
    public:
        OperationThread();

        void setParent(Object* parent) { _parent = parent; }

        Object* getParent() { return _parent.get(); }

        const Object* getParent() const { return _parent.get(); }


        /** Set the OperationQueue. */
		//设置操作队列
        void setOperationQueue(OperationQueue* opq);

        /** Get the OperationQueue. */
		//返回操作队列
        OperationQueue* getOperationQueue() { return _operationQueue.get(); }

        /** Get the const OperationQueue. */
		//返回操作队列常亮
        const OperationQueue* getOperationQueue() const { return _operationQueue.get(); }


        /** Add operation to end of OperationQueue, this will be
          * executed by the graphics thread once this operation gets to the head of the queue.*/
		//添加操作，操作队列不存在，则创建。
        void add(Operation* operation);

        /** Remove operation from OperationQueue.*/
		//移除操作
        void remove(Operation* operation);

        /** Remove named operation from OperationQueue.*/
		//根据名字，移除操作
        void remove(const std::string& name);

        /** Remove all operations from OperationQueue.*/
		//移除所有操作
        void removeAllOperations();


        /** Get the operation currently being run.*/
        osg::ref_ptr<Operation> getCurrentOperation() { return _currentOperation; }

        /** Run does the opertion thread run loop.*/
        virtual void run();

        void setDone(bool done);

        bool getDone() const { return _done; }

        /** Cancel this graphics thread.*/
        virtual int cancel();

    protected:

        virtual ~OperationThread();

        observer_ptr<Object>            _parent; //操作线程的父对象

        bool                            _done;

        OpenThreads::Mutex              _threadMutex; //互斥对象
        osg::ref_ptr<OperationQueue>    _operationQueue; //操作队列对象
        osg::ref_ptr<Operation>         _currentOperation; //当前操作对象

};

typedef OperationThread OperationsThread;

}

#endif
