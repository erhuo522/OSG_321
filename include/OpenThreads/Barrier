/* -*-c++-*- OpenThreads library, Copyright (C) 2002 - 2007  The Open Thread Group
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
*/


//
// Barrier - C++ barrier class
// ~~~~~~~
//

#ifndef _OPENTHREADS_BARRIER_
#define _OPENTHREADS_BARRIER_

#include <OpenThreads/Exports>

namespace OpenThreads {


/**
  * 线程栅栏类。这是一个对于线程同步颇为重要的阻塞器接口，它的构造函
  * 数与BlockCount 类似，可以设置一个整数值，我们可以把这个值理解成栅栏的“强度”。每
  * 个执行了Barrier::block()函数的线程都将被阻塞；当被阻塞在栅栏处的线程达到指定的数目
  * 时，就好比栅栏无法支撑那么大的强度一样，栅栏将被冲开，所有的线程将被释放。重要的
  * 是，这些线程是几乎同时释放的，也就保证了线程执行的同步性。
  */

class OPENTHREAD_EXPORT_DIRECTIVE Barrier {

public:

    //构造函数，numThreads可以阻塞的最大线程数量
    Barrier(int numThreads=0);

    //析构
    virtual ~Barrier();

    //重置，回到初始状态
    virtual void reset();

    /**
     *  Block until numThreads threads have entered the barrier.
     */
    virtual void block(unsigned int numThreads=0);

    //无视阻塞数量，直接释放当前栅栏。
    virtual void release();

    //获取当前阻塞的线程数量
    virtual int numThreadsCurrentlyBlocked();

	//将栅栏置为不可用
    void invalidate();

private:

    /**
     *  Private copy constructor, to prevent tampering.
     */
    Barrier(const Barrier &/*b*/) {};

    /**
     *  Private copy assignment, to prevent tampering.
     */
    Barrier &operator=(const Barrier &/*b*/) {return *(this);};

    /**
     *  Implementation-specific private data.
     */
    void *_prvData;

	//表示栅栏是否可用
    bool _valid;

};

}

#endif // !_OPENTHREADS_BARRIER_

